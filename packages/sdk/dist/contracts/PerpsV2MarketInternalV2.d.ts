import { Contract as MultiCallContract } from 'ethcall';
import { ethers, Contract } from 'ethers';
import { BigNumber } from '@ethersproject/bignumber';
import KwentaSDK from '..';
import { FuturesMarketKey, PotentialTradeStatus } from '../types/futures';
type TradeParams = {
    sizeDelta: BigNumber;
    fillPrice: BigNumber;
    desiredFillPrice: BigNumber;
    takerFee: BigNumber;
    makerFee: BigNumber;
    trackingCode: string;
};
type Position = {
    id: string;
    lastPrice: BigNumber;
    size: BigNumber;
    margin: BigNumber;
    lastFundingIndex: BigNumber;
};
type MarketSettings = {
    minInitialMargin: BigNumber;
    takerFeeOffchainDelayedOrder: BigNumber;
    makerFeeOffchainDelayedOrder: BigNumber;
    maxLeverage: BigNumber;
    maxMarketValue: BigNumber;
    skewScale: BigNumber;
    liquidationPremiumMultiplier: BigNumber;
    maxFundingVelocity: BigNumber;
    liquidationBufferRatio: BigNumber;
    liquidationFeeRatio: BigNumber;
    maxKeeperFee: BigNumber;
    minKeeperFee: BigNumber;
    keeperLiquidationFee: BigNumber;
};
declare class FuturesMarketInternal {
    _sdk: KwentaSDK;
    _provider: ethers.providers.Provider;
    _perpsV2MarketContract: Contract;
    _perpsV2MarketSettings: MultiCallContract | undefined;
    _marketKeyBytes: string;
    _block: ethers.providers.Block | null;
    _onChainData: {
        assetPrice: BigNumber;
        marketSkew: BigNumber;
        marketSize: BigNumber;
        fundingSequenceLength: BigNumber;
        fundingLastRecomputed: number;
        fundingRateLastRecomputed: number;
        accruedFunding: BigNumber;
    };
    _marketSettings: MarketSettings | undefined;
    _cache: Record<string, BigNumber>;
    constructor(sdk: KwentaSDK, provider: ethers.providers.Provider, marketKey: FuturesMarketKey, marketAddress: string);
    getTradePreview: (account: string, sizeDelta: BigNumber, marginDelta: BigNumber, tradePrice: BigNumber) => Promise<{
        liqPrice: ethers.BigNumber;
        fee: ethers.BigNumber;
        price: ethers.BigNumber;
        status: PotentialTradeStatus;
        id: string;
        lastPrice: ethers.BigNumber;
        size: ethers.BigNumber;
        margin: ethers.BigNumber;
        lastFundingIndex: ethers.BigNumber;
    }>;
    _postTradeDetails: (oldPos: Position, tradeParams: TradeParams, marginDelta: BigNumber) => Promise<{
        newPos: Position;
        status: PotentialTradeStatus;
        fee: BigNumber;
    }>;
    _liquidationPremium: (positionSize: BigNumber, currentPrice: BigNumber) => Promise<ethers.BigNumber | 0>;
    _orderFee: (tradeParams: TradeParams) => Promise<ethers.BigNumber>;
    _recomputeMarginWithDelta: (position: Position, price: BigNumber, marginDelta: BigNumber) => Promise<{
        margin: ethers.BigNumber;
        status: PotentialTradeStatus;
    }>;
    _marginPlusProfitFunding: (position: Position, price: BigNumber) => Promise<ethers.BigNumber>;
    _profitLoss: (position: Position, price: BigNumber) => ethers.BigNumber;
    _nextFundingEntry: (price: BigNumber) => Promise<any>;
    _latestFundingIndex: () => Promise<ethers.BigNumber>;
    _netFundingPerUnit: (startIndex: BigNumber, price: BigNumber) => Promise<any>;
    _proportionalElapsed: () => Promise<ethers.BigNumber>;
    _currentFundingVelocity: () => Promise<ethers.BigNumber>;
    _currentFundingRate: () => Promise<ethers.BigNumber>;
    _unrecordedFunding: (price: BigNumber) => Promise<ethers.BigNumber>;
    _proportionalSkew: () => Promise<ethers.BigNumber>;
    _approxLiquidationPrice: (position: Position, currentPrice: BigNumber) => Promise<ethers.BigNumber>;
    _exactLiquidationMargin: (positionSize: BigNumber, price: BigNumber) => Promise<ethers.BigNumber>;
    _liquidationMargin: (positionSize: BigNumber, price: BigNumber) => Promise<ethers.BigNumber>;
    _liquidationFee: (positionSize: BigNumber, price: BigNumber) => Promise<ethers.BigNumber>;
    _stakerFee: (positionSize: BigNumber, price: BigNumber) => Promise<ethers.BigNumber>;
    _fillPrice: (size: BigNumber, price: BigNumber) => Promise<ethers.BigNumber>;
    _canLiquidate: (position: Position, price: BigNumber) => Promise<boolean>;
    _remainingLiquidatableMargin: (position: Position, price: BigNumber) => Promise<ethers.BigNumber>;
    _orderSizeTooLarge: (maxSize: BigNumber, oldSize: BigNumber, newSize: BigNumber) => Promise<boolean>;
    _maxLeverageForSize: (size: BigNumber) => Promise<ethers.BigNumber>;
    _sameSide(a: BigNumber, b: BigNumber): boolean;
    _batchGetSettings: () => Promise<MarketSettings>;
    _getSetting: (settingType: keyof MarketSettings) => Promise<ethers.BigNumber>;
}
export default FuturesMarketInternal;
