"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PriceServiceConnection = void 0;
const price_service_sdk_1 = require("@pythnetwork/price-service-sdk");
const axios_1 = require("axios");
const axios_retry_1 = require("axios-retry");
const ResillientWebSocket_1 = require("./ResillientWebSocket");
const utils_1 = require("./utils");
class PriceServiceConnection {
    httpClient;
    priceFeedCallbacks;
    wsClient;
    wsEndpoint;
    logger;
    priceFeedRequestConfig;
    /**
     * Custom handler for web socket errors (connection and message parsing).
     *
     * Default handler only logs the errors.
     */
    onWsError;
    /**
     * Constructs a new Connection.
     *
     * @param endpoint endpoint URL to the price service. Example: https://website/example/
     * @param config Optional PriceServiceConnectionConfig for custom configurations.
     */
    constructor(endpoint, config) {
        this.httpClient = axios_1.default.create({
            baseURL: endpoint,
            timeout: config?.timeout || 5000,
        });
        (0, axios_retry_1.default)(this.httpClient, {
            retries: config?.httpRetries || 3,
            retryDelay: axios_retry_1.default.exponentialDelay,
        });
        this.priceFeedRequestConfig = {
            binary: config?.priceFeedRequestConfig?.binary,
            verbose: config?.priceFeedRequestConfig?.verbose ?? config?.verbose,
        };
        this.priceFeedCallbacks = new Map();
        this.logger = config?.logger;
        this.onWsError = (error) => {
            this.logger?.error(error);
        };
        this.wsEndpoint = (0, utils_1.makeWebsocketUrl)(endpoint);
    }
    /**
     * Fetch Latest PriceFeeds of given price ids.
     * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
     *
     * @param priceIds Array of hex-encoded price ids.
     * @returns Array of PriceFeeds
     */
    async getLatestPriceFeeds(priceIds) {
        if (priceIds.length === 0) {
            return [];
        }
        const response = await this.httpClient.get("/api/latest_price_feeds", {
            params: {
                ids: priceIds,
                verbose: this.priceFeedRequestConfig.verbose,
                binary: this.priceFeedRequestConfig.binary,
            },
        });
        const priceFeedsJson = response.data;
        return priceFeedsJson.map((priceFeedJson) => price_service_sdk_1.PriceFeed.fromJson(priceFeedJson));
    }
    /**
     * Fetch latest VAA of given price ids.
     * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
     *
     * This function is coupled to wormhole implemntation.
     *
     * @param priceIds Array of hex-encoded price ids.
     * @returns Array of base64 encoded VAAs.
     */
    async getLatestVaas(priceIds) {
        const response = await this.httpClient.get("/api/latest_vaas", {
            params: {
                ids: priceIds,
            },
        });
        return response.data;
    }
    /**
     * Fetch the earliest VAA of the given price id that is published since the given publish time.
     * This will throw an error if the given publish time is in the future, or if the publish time
     * is old and the price service endpoint does not have a db backend for historical requests.
     * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price id)
     *
     * This function is coupled to wormhole implemntation.
     *
     * @param priceId Hex-encoded price id.
     * @param publishTime Epoch timestamp in seconds.
     * @returns Tuple of VAA and publishTime.
     */
    async getVaa(priceId, publishTime) {
        const response = await this.httpClient.get("/api/get_vaa", {
            params: {
                id: priceId,
                publish_time: publishTime,
            },
        });
        return [response.data.vaa, response.data.publishTime];
    }
    /**
     * Fetch the list of available price feed ids.
     * This will throw an axios error if there is a network problem or the price service returns a non-ok response.
     *
     * @returns Array of hex-encoded price ids.
     */
    async getPriceFeedIds() {
        const response = await this.httpClient.get("/api/price_feed_ids");
        return response.data;
    }
    /**
     * Subscribe to updates for given price ids.
     *
     * It will start a websocket connection if it's not started yet.
     * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
     * it calls `connection.onWsError`. If you want to handle the errors you should set the
     * `onWsError` function to your custom error handler.
     *
     * @param priceIds Array of hex-encoded price ids.
     * @param cb Callback function that is called with a PriceFeed upon updates to given price ids.
     */
    async subscribePriceFeedUpdates(priceIds, cb) {
        if (this.wsClient === undefined) {
            await this.startWebSocket();
        }
        priceIds = priceIds.map((priceId) => (0, utils_1.removeLeading0xIfExists)(priceId));
        const newPriceIds = [];
        for (const id of priceIds) {
            if (!this.priceFeedCallbacks.has(id)) {
                this.priceFeedCallbacks.set(id, new Set());
                newPriceIds.push(id);
            }
            this.priceFeedCallbacks.get(id).add(cb);
        }
        const message = {
            ids: newPriceIds,
            type: "subscribe",
            verbose: this.priceFeedRequestConfig.verbose,
            binary: this.priceFeedRequestConfig.binary,
        };
        await this.wsClient?.send(JSON.stringify(message));
    }
    /**
     * Unsubscribe from updates for given price ids.
     *
     * It will close the websocket connection if it's not subscribed to any price feed updates anymore.
     * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
     * it calls `connection.onWsError`. If you want to handle the errors you should set the
     * `onWsError` function to your custom error handler.
     *
     * @param priceIds Array of hex-encoded price ids.
     * @param cb Optional callback, if set it will only unsubscribe this callback from updates for given price ids.
     */
    async unsubscribePriceFeedUpdates(priceIds, cb) {
        if (this.wsClient === undefined) {
            await this.startWebSocket();
        }
        priceIds = priceIds.map((priceId) => (0, utils_1.removeLeading0xIfExists)(priceId));
        const removedPriceIds = [];
        for (const id of priceIds) {
            if (this.priceFeedCallbacks.has(id)) {
                let idRemoved = false;
                if (cb === undefined) {
                    this.priceFeedCallbacks.delete(id);
                    idRemoved = true;
                }
                else {
                    this.priceFeedCallbacks.get(id).delete(cb);
                    if (this.priceFeedCallbacks.get(id).size === 0) {
                        this.priceFeedCallbacks.delete(id);
                        idRemoved = true;
                    }
                }
                if (idRemoved) {
                    removedPriceIds.push(id);
                }
            }
        }
        const message = {
            ids: removedPriceIds,
            type: "unsubscribe",
        };
        await this.wsClient?.send(JSON.stringify(message));
        if (this.priceFeedCallbacks.size === 0) {
            this.closeWebSocket();
        }
    }
    /**
     * Starts connection websocket.
     *
     * This function is called automatically upon subscribing to price feed updates.
     */
    async startWebSocket() {
        if (this.wsEndpoint === undefined) {
            throw new Error("Websocket endpoint is undefined.");
        }
        this.wsClient = new ResillientWebSocket_1.ResilientWebSocket(this.wsEndpoint, this.logger);
        this.wsClient.onError = this.onWsError;
        this.wsClient.onReconnect = () => {
            if (this.priceFeedCallbacks.size > 0) {
                const message = {
                    ids: Array.from(this.priceFeedCallbacks.keys()),
                    type: "subscribe",
                    verbose: this.priceFeedRequestConfig.verbose,
                    binary: this.priceFeedRequestConfig.binary,
                };
                this.logger?.info("Resubscribing to existing price feeds.");
                this.wsClient?.send(JSON.stringify(message));
            }
        };
        this.wsClient.onMessage = (data) => {
            this.logger?.info(`Received message ${data.toString()}`);
            let message;
            try {
                message = JSON.parse(data.toString());
            }
            catch (e) {
                this.logger?.error(`Error parsing message ${data.toString()} as JSON.`);
                this.logger?.error(e);
                this.onWsError(e);
                return;
            }
            if (message.type === "response") {
                if (message.status === "error") {
                    this.logger?.error(`Error response from the websocket server ${message.error}.`);
                    this.onWsError(new Error(message.error));
                }
            }
            else if (message.type === "price_update") {
                let priceFeed;
                try {
                    priceFeed = price_service_sdk_1.PriceFeed.fromJson(message.price_feed);
                }
                catch (e) {
                    this.logger?.error(`Error parsing price feeds from message ${data.toString()}.`);
                    this.logger?.error(e);
                    this.onWsError(e);
                    return;
                }
                if (this.priceFeedCallbacks.has(priceFeed.id)) {
                    for (const cb of this.priceFeedCallbacks.get(priceFeed.id)) {
                        cb(priceFeed);
                    }
                }
            }
            else {
                this.logger?.warn(`Ignoring unsupported server response ${data.toString()}.`);
            }
        };
        await this.wsClient.startWebSocket();
    }
    /**
     * Closes connection websocket.
     *
     * At termination, the websocket should be closed to finish the
     * process elegantly. It will automatically close when the connection
     * is subscribed to no price feeds.
     */
    closeWebSocket() {
        this.wsClient?.closeWebSocket();
        this.wsClient = undefined;
        this.priceFeedCallbacks.clear();
    }
}
exports.PriceServiceConnection = PriceServiceConnection;
