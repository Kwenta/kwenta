import { HexString, PriceFeed } from "@pythnetwork/price-service-sdk";
import { Logger } from "ts-log";
export type DurationInMs = number;
export type PriceFeedRequestConfig = {
    verbose?: boolean;
    binary?: boolean;
};
export type PriceServiceConnectionConfig = {
    timeout?: DurationInMs;
    /**
     * Number of times a HTTP request will be retried before the API returns a failure. Default: 3.
     *
     * The connection uses exponential back-off for the delay between retries. However,
     * it will timeout regardless of the retries at the configured `timeout` time.
     */
    httpRetries?: number;
    logger?: Logger;
    verbose?: boolean;
    priceFeedRequestConfig?: PriceFeedRequestConfig;
};
export type PriceFeedUpdateCallback = (priceFeed: PriceFeed) => void;
export declare class PriceServiceConnection {
    private httpClient;
    private priceFeedCallbacks;
    private wsClient;
    private wsEndpoint;
    private logger;
    private priceFeedRequestConfig;
    /**
     * Custom handler for web socket errors (connection and message parsing).
     *
     * Default handler only logs the errors.
     */
    onWsError: (error: Error) => void;
    /**
     * Constructs a new Connection.
     *
     * @param endpoint endpoint URL to the price service. Example: https://website/example/
     * @param config Optional PriceServiceConnectionConfig for custom configurations.
     */
    constructor(endpoint: string, config?: PriceServiceConnectionConfig);
    /**
     * Fetch Latest PriceFeeds of given price ids.
     * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
     *
     * @param priceIds Array of hex-encoded price ids.
     * @returns Array of PriceFeeds
     */
    getLatestPriceFeeds(priceIds: HexString[]): Promise<PriceFeed[] | undefined>;
    /**
     * Fetch latest VAA of given price ids.
     * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
     *
     * This function is coupled to wormhole implemntation.
     *
     * @param priceIds Array of hex-encoded price ids.
     * @returns Array of base64 encoded VAAs.
     */
    getLatestVaas(priceIds: HexString[]): Promise<string[]>;
    /**
     * Fetch the earliest VAA of the given price id that is published since the given publish time.
     * This will throw an error if the given publish time is in the future, or if the publish time
     * is old and the price service endpoint does not have a db backend for historical requests.
     * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price id)
     *
     * This function is coupled to wormhole implemntation.
     *
     * @param priceId Hex-encoded price id.
     * @param publishTime Epoch timestamp in seconds.
     * @returns Tuple of VAA and publishTime.
     */
    getVaa(priceId: HexString, publishTime: EpochTimeStamp): Promise<[string, EpochTimeStamp]>;
    /**
     * Fetch the list of available price feed ids.
     * This will throw an axios error if there is a network problem or the price service returns a non-ok response.
     *
     * @returns Array of hex-encoded price ids.
     */
    getPriceFeedIds(): Promise<HexString[]>;
    /**
     * Subscribe to updates for given price ids.
     *
     * It will start a websocket connection if it's not started yet.
     * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
     * it calls `connection.onWsError`. If you want to handle the errors you should set the
     * `onWsError` function to your custom error handler.
     *
     * @param priceIds Array of hex-encoded price ids.
     * @param cb Callback function that is called with a PriceFeed upon updates to given price ids.
     */
    subscribePriceFeedUpdates(priceIds: HexString[], cb: PriceFeedUpdateCallback): Promise<void>;
    /**
     * Unsubscribe from updates for given price ids.
     *
     * It will close the websocket connection if it's not subscribed to any price feed updates anymore.
     * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
     * it calls `connection.onWsError`. If you want to handle the errors you should set the
     * `onWsError` function to your custom error handler.
     *
     * @param priceIds Array of hex-encoded price ids.
     * @param cb Optional callback, if set it will only unsubscribe this callback from updates for given price ids.
     */
    unsubscribePriceFeedUpdates(priceIds: HexString[], cb?: PriceFeedUpdateCallback): Promise<void>;
    /**
     * Starts connection websocket.
     *
     * This function is called automatically upon subscribing to price feed updates.
     */
    startWebSocket(): Promise<void>;
    /**
     * Closes connection websocket.
     *
     * At termination, the websocket should be closed to finish the
     * process elegantly. It will automatically close when the connection
     * is subscribed to no price feeds.
     */
    closeWebSocket(): void;
}
//# sourceMappingURL=PriceServiceConnection.d.ts.map