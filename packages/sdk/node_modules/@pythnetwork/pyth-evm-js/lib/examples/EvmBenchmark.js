"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_1 = __importDefault(require("web3"));
const yargs_1 = __importDefault(require("yargs"));
const helpers_1 = require("yargs/helpers");
const index_1 = require("../index");
const hdwallet_provider_1 = __importDefault(require("@truffle/hdwallet-provider"));
const IPyth_json_1 = __importDefault(require("@pythnetwork/pyth-sdk-solidity/abis/IPyth.json"));
const argv = (0, yargs_1.default)((0, helpers_1.hideBin)(process.argv))
    .option("network", {
    description: "RPC of the network to relay on.",
    type: "string",
    required: true,
})
    .option("endpoint", {
    description: "Endpoint URL for the price service. e.g: https://endpoint/example",
    type: "string",
    required: true,
})
    .option("pyth-contract", {
    description: "Pyth contract address.",
    type: "string",
    required: true,
})
    .option("price-id", {
    description: "Price feed id (in hex) to fetch" + " e.g: 0xf9c0172ba10dfa4d19088d...",
    type: "string",
    required: true,
})
    .option("timestamp", {
    description: "Timestamp of the prices to fetch" + " e.g., 2022-",
    type: "string",
    required: true,
})
    .option("mnemonic", {
    description: "Mnemonic (private key) for sender",
    type: "string",
    required: true,
})
    .help()
    .alias("help", "h")
    .parserConfiguration({
    "parse-numbers": false,
})
    .parseSync();
const network = argv.network;
const pythContractAddr = argv.pythContract;
const connection = new index_1.EvmPriceServiceConnection(argv.endpoint);
async function run() {
    const provider = new hdwallet_provider_1.default({
        mnemonic: {
            phrase: argv.mnemonic,
        },
        providerOrUrl: network,
    });
    // @ts-ignore
    const web3 = new web3_1.default(provider);
    const priceId = argv.priceId;
    // The unix timestamp in seconds
    const unixTimestamp = Date.parse(argv.timestamp) / 1000;
    console.log(`Querying unix timestamp: ${unixTimestamp}`);
    const [priceFeedUpdateVaa, updateTimestamp] = await connection.getVaa(priceId, unixTimestamp);
    console.log(`Next pyth update was at: ${updateTimestamp}`);
    console.log(priceFeedUpdateVaa);
    const priceFeedUpdate = "0x" + Buffer.from(priceFeedUpdateVaa, "base64").toString("hex");
    const pythContract = new web3.eth.Contract(IPyth_json_1.default, pythContractAddr, {
        from: provider.getAddress(0),
    });
    const updateFee = await pythContract.methods
        .getUpdateFee([priceFeedUpdate])
        .call();
    console.log(`Update fee: ${updateFee}`);
    // In real use cases, you would pass the update to your contract, then call parsePriceFeedUpdates within your contract.
    // When invoked on-chain, this function will return a PriceFeed struct containing the data in the price update
    // (such as the current price).
    await pythContract.methods
        .parsePriceFeedUpdates([priceFeedUpdate], [priceId], 
    // parsePriceFeedUpdates will reject any price update outside of the time window provided in the following
    // two arguments. Integrators can use this to specify the timestamp of the update they are expecting.
    unixTimestamp, unixTimestamp + 5)
        .send({ value: updateFee })
        .on("transactionHash", (hash) => {
        console.log(`Tx hash: ${hash}`);
    })
        .on("error", (err, receipt) => {
        console.error(receipt);
        throw err;
    });
    provider.engine.stop();
}
run();
