#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gen = exports.pull = void 0;
const commander_1 = require("commander");
const fs_1 = __importDefault(require("fs"));
const constants_1 = require("./constants");
const methods_1 = __importDefault(require("./methods"));
const typescript_1 = __importDefault(require("typescript"));
const axios_1 = __importDefault(require("axios"));
function pull(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield (0, axios_1.default)(options.url, {
            method: 'POST',
            data: JSON.stringify({ query: constants_1.INTROSPECTION_QUERY })
        });
        const rawSchema = res.data.data.__schema;
        return rawSchema;
    });
}
exports.pull = pull;
function gen({ schema, method, js }) {
    if (!methods_1.default[method]) {
        throw new Error(`method "${method}" not supported. please try one of: ${Object.keys(methods_1.default).join(', ')}`);
    }
    const tsCode = methods_1.default[method](schema);
    if (js) {
        return typescript_1.default.transpile(tsCode);
    }
    else {
        return prettifyTypescript(tsCode);
    }
}
exports.gen = gen;
function prettifyTypescript(rawTs) {
    const sourceFile = typescript_1.default.createSourceFile('subgraph.ts', rawTs, typescript_1.default.ScriptTarget.Latest);
    const printer = typescript_1.default.createPrinter({ newLine: typescript_1.default.NewLineKind.LineFeed });
    return printer.printFile(sourceFile);
}
function printResultDiagnosticInfo(res) {
    const sourceFile = typescript_1.default.createSourceFile('subgraph.ts', res, typescript_1.default.ScriptTarget.Latest);
    const printer = typescript_1.default.createPrinter({ newLine: typescript_1.default.NewLineKind.LineFeed });
    //console.log(printer.printNode(ts.EmitHint.SourceFile, sourceFile, sourceFile));
    console.log('generated subgraph queries:');
    typescript_1.default.forEachChild(sourceFile, node => {
        if (typescript_1.default.isVariableStatement(node)) {
            const varNode = node.declarationList.declarations[0];
            if (typescript_1.default.isFunctionLike(varNode.initializer)) {
                console.log(`- created: ${printer.printNode(typescript_1.default.EmitHint.Unspecified, varNode.name, sourceFile)}(${printer.printList(typescript_1.default.ListFormat.CommaListElements, varNode.initializer.parameters, sourceFile)})`);
            }
        }
    });
}
if (require.main === module) {
    const program = new commander_1.Command();
    program
        .command('pull <url>')
        .description('retrieves the graphql schema associated with the given subgraph url')
        .action((options) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            console.error('schema pull successful!');
            console.log(JSON.stringify(yield pull({ url: options })));
        }
        catch (err) {
            console.error('failed to pull:', err);
        }
    }));
    program.command('gen')
        .description('generate the typescript code to fetch from a subgraph')
        .option('-u, --url <location>', 'subgraph to extract schema from')
        .option('-s, --schema <path to .json>', 'location of a schema previously downloded with pull')
        .option('-m, --method <name>', `which top level generator to use. options: ${Object.keys(methods_1.default).join(', ')}`, 'plain')
        .option('-o, --out <file>', 'file to export the generated typescript files')
        .option('--js', 'output as plain javascript (instead of typescript)')
        .action((options) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (options.file && options.url) {
                throw new Error('only one of file or url should be specified');
            }
            let schema;
            if (options.url) {
                schema = yield pull(options);
            }
            else if (options.schema) {
                schema = JSON.parse(fs_1.default.readFileSync(options.schema).toString());
            }
            else {
                throw new Error('supply either a file or url');
            }
            const res = gen(Object.assign(Object.assign({}, options), { schema }));
            if (options.out) {
                fs_1.default.writeFileSync(options.out, res);
                printResultDiagnosticInfo(res);
                console.log('wrote file:', options.out);
            }
            else {
                console.log(res);
            }
        }
        catch (err) {
            console.error('failed to gen:', err);
        }
    }));
    program.parse(process.argv);
}
